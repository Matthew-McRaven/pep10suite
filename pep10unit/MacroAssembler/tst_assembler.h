#ifndef TST_ASSEMBLER_H
#define TST_ASSEMBLER_H

#include <QTest>
#include "macromodules.h"

class MacroRegistry;
class MacroPreprocessor;
class MacroAssembler;
struct ModuleAssemblyGraph;
class AssemblerTest : public QObject
{
    Q_OBJECT
public:
    AssemblerTest();
    ~AssemblerTest();

private slots:
    void initTestCase();
    void cleanupTestCase();

    // Test cases where an otherwise valid program forgets a .END.
    void case_missingEnd_data();
    void case_missingEnd();

    // Test that true syntax errors are propogated to the end user.
    void case_syntaxError_data();
    void case_syntaxError();

    // Test cases for tokens generated by syntax errors.
    void case_unexpectedToken_data();
    void case_unexpectedToken();

    // Test cases where an EOL is encountered too early.
    void case_unexpectedEOL_data();
    void case_unexpectedEOL();

    // Test cases where something other than a comment is detected after a newline.
    // However, this should be impossible to hit, since lines always have a \n appened to them.
    //void case_expectNewlineCommnet_data();
    //void case_expectNewlineCommnet();

    // Test cases where a symbol is declared unexpctedly.
    void case_unexpectedSymbolDeclaration_data();
    void case_unexpectedSymbolDeclaration();

    // Test cases with non-existant mnemonics e.g. "YETI".
    void case_invalidMnemonic_data();
    void case_invalidMnemonic();

    // Test cases for dot commands that may only occur in operating system.
    void case_onlyInOS_data();
    void case_onlyInOS();

    // Test cases for invalid dot commands e.g. "YETI".
    void case_invalidDotCommand_data();
    void case_invalidDotCommand();

    // Test cases where a symbol is declared to be too long.
    void case_symbolTooLong_data();
    void case_symbolTooLong();

    // Test cases where an instruction that requires an addressing mode
    // is not given one.
    void case_badAddrMode_data();
    void case_badAddrMode();

    /*
     * Since the preprocessor aggressively catches errors concerning macro names
     * and argument counts, these tests have been commented out, and their
     * implementations removed. While our macro assembler is defensive against
     * this family of errors, it is impossible for it to occur in practice.
     */
    // Test cases where the invoked macro does not exist.
    //void case_noSuchMacro_data();
    //void case_noSuchMacro();
    // Test cases where the invoked macro is given the wrong number of arguments.
    //void case_badMacroArgCount_data();
    //void case_badMacroArgCount();

    // Test cases where something is wrong with the macro argument list,
    // but the macro does exist, and has the correct number of arguments.
    void case_badMacroSub_data();
    void case_badMacroSub();

    // Test cases where a nonunary instruction is not given an operand specifier.
    void case_expectOperand_data();
    void case_expectOperand();

    // Test cases where a value is incapable of being represented by a byte.
    void case_byteOutOfRange_data();
    void case_byteOutOfRange();

    // Test cases where a value is incapable of being represented by a word.
    void case_wordOutOfRange_data();
    void case_wordOutOfRange();

    // Test cases where .ADDRSS is given a bad argument.
    void case_badAddrssArg_data();
    void case_badAddrssArg();

    // Test cases where .ALIGN is given a bad argument.
    void case_badAlignArg_data();
    void case_badAlignArg();

    // Test cases where .ASCII is given a bad argument.
    void case_badAsciiArg_data();
    void case_badAsciiArg();

    // Test cases where .BLOCK is given a bad argument.
    //void case_badBlockArg_data();
    //void case_badBlockArg();

    // Test cases where .BURN is given a bad argument.
    //void case_badBurnArg_data();
    //void case_badBurnArg();

    // Test cases where .BYTE is given a bad argument.
    //void case_badByteArg_data();
    //void case_badByteArg();

    // Test cases where .USCALL is given a bad argument.
    //void case_badUExportArg_data();
    //void case_badUExportArg();

    // Test cases where .SCALL is given a bad argument.
    //void case_badScallArg_data();
    //void case_badScallArg();

    // Test cases where .USCALL is given a bad argument.
    //void case_badUScallArg_data();
    //void case_badUScallArg();

private:
    QSharedPointer<MacroRegistry> registry;
    QSharedPointer<MacroPreprocessor> preprocessor;
    QSharedPointer<MacroAssembler> assembler;
    void preprocess(ModuleAssemblyGraph& graph, ModuleType programType);
    void execute();
};

#endif // TST_ASSEMBLER_H
